// Generated by CoffeeScript 1.7.1

/*
@fileOverview This file contains JavaScript code that handles the HTML document where HTML is rendered for a SafeFrame, as well as defining the External Vendor/Client API.
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.3
 */


/*
@namespace $sf.ext The external vendor / client API for functionality inside a SafeFrame
@name $sf.ext
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require("../shared/base");

  module.exports = function(isExternal) {
    return (function(window, sf) {
      var COLLAPSE_COMMAND, DG, DOM_WATCH_INTERVAL, DP, DS, ERROR_COMMAND, EXPAND_COMMAND, GUID_VALID_TIME, IE_ATTACH, IE_DETACH, LOAD, MAX_MSG_WAIT_TIME, MSG, NOTIFY_CLICKED, NOTIFY_COLLAPSE, NOTIFY_COLLAPSED, NOTIFY_EXPAND, NOTIFY_FAILURE, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, NOTIFY_LOADED, NOTIFY_READ_COOKIE, NOTIFY_RELOAD, NOTIFY_REQUESTED, NOTIFY_UNVIEWED, NOTIFY_VIEWED, NOTIFY_WRITE_COOKIE, OBJ, ONLOAD, ONMSG, ONUNLOAD, ON_STR, OUR_TAG_CLS_NAME, ParamHash, STATUS_COLLAPSED, STATUS_COLLAPSING, STATUS_EXPANDED, STATUS_EXPANDING, TOLOWERCASE, UNLOAD, W3C_ATTACH, W3C_DETACH, adShown, can_use_html5, click, cmdRetries, collapse, cookie, d, deleteMeta, dom, env, err_msg_timer_id, err_msgs, expand, force_collapse, frame_id, geom, geom_info, guid, hasLoaded, host_cname, ie_old_attach, ie_old_detach, iframes, inViewPercentage, init_height, init_width, inline_handler_timer_id, isAdShown, isIE, is_expanded, is_registered, lang, lib, loaded, message, messageQueue, meta, msgclient_fb, originalWrite, orphan_timer_id, par, pending_msg, pos_id, pos_meta, register, reload, render, render_conf, render_params, sandbox_cb, showAd, status, supports, unload_handlers, unviewed, viewed, w3c_old_attach, w3c_old_detach, win, winHasFocus, win_has_focus, _append, _attach, _attach_override, _attr, _call_client_fb, _call_raw_evt_func, _check_orphaned, _cnum, _collapse, _construction, _create_stylesheet, _cstr, _destruction, _detach, _detach_override, _detect_bad_iframe, _elt, _fire_sandbox_callback, _handle_err, _handle_load, _handle_msg, _handle_unload, _nuke_doc, _purge, _reattach_messaging, _receive_msg, _render, _report_errs, _requested, _reset_inline_handlers, _send_cmd, _send_msg, _set_alignment, _set_hyperlink_targets, _setup_win_evt_props, _shiftMessageQueue, _tags, _ue, _wrapiFrame;
      win = window;
      LOAD = "load";
      ON_STR = "on";
      MSG = "message";
      UNLOAD = "un" + LOAD;
      ONUNLOAD = ON_STR + UNLOAD;
      ONMSG = ON_STR + MSG;
      ONLOAD = ON_STR + LOAD;
      DG = "__defineGetter__";
      DS = "__defineSetter__";
      DP = "__defineProperty__";
      W3C_ATTACH = "addEventListener";
      W3C_DETACH = "removeEventListener";
      IE_ATTACH = "attachEvent";
      IE_DETACH = "detachEvent";
      TOLOWERCASE = "toLowerCase";
      EXPAND_COMMAND = "exp-ovr";
      COLLAPSE_COMMAND = "collapse";
      ERROR_COMMAND = "error";
      NOTIFY_GEOM_UPDATE = "geom-update";
      NOTIFY_EXPAND = "expand";
      NOTIFY_FOCUS_CHANGE = "focus-change";
      NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
      NOTIFY_COLLAPSED = NOTIFY_COLLAPSE + "d";
      NOTIFY_FAILURE = "failed";
      NOTIFY_READ_COOKIE = "read-cookie";
      NOTIFY_WRITE_COOKIE = "write-cookie";
      NOTIFY_CLICKED = "clicked";
      NOTIFY_VIEWED = "viewed";
      NOTIFY_UNVIEWED = "unviewed";
      NOTIFY_LOADED = "loaded";
      NOTIFY_REQUESTED = "requested";
      NOTIFY_RELOAD = "reload";
      STATUS_COLLAPSED = NOTIFY_COLLAPSED;
      STATUS_EXPANDED = NOTIFY_EXPAND + "ed";
      STATUS_COLLAPSING = "collapsing";
      STATUS_EXPANDING = NOTIFY_EXPAND + "ing";
      OUR_TAG_CLS_NAME = "sf";
      MAX_MSG_WAIT_TIME = 4000;
      DOM_WATCH_INTERVAL = 3000;
      GUID_VALID_TIME = 30000;
      OBJ = "object";
      d = win && win.document;
      par = win && win.parent;
      lib = sf.lib;
      env = sf.env;
      lang = lib.lang;
      ParamHash = lang.ParamHash;
      dom = lib.dom;
      iframes = dom.iframes;
      msgclient_fb = dom.msgclient_fb;
      isIE = env.isIE;
      _ue = win.unescape;
      _cstr = lang.cstr;
      _cnum = lang.cnum;
      _append = dom.append;
      _tags = dom.tags;
      _elt = dom && dom.elt;
      _purge = dom && dom.purge;
      _attach = dom && dom.attach;
      _detach = dom && dom.detach;
      _attr = dom && dom.attr;
      hasLoaded = false;
      is_expanded = false;
      force_collapse = false;
      is_registered = false;
      init_width = 0;
      init_height = 0;
      sandbox_cb = null;
      pending_msg = null;
      messageQueue = [];
      geom_info = null;
      pos_meta = null;
      win_has_focus = false;
      guid = "";
      host_cname = "";
      can_use_html5 = false;
      frame_id = "";
      pos_id = "";
      err_msg_timer_id = 0;
      orphan_timer_id = 0;
      inline_handler_timer_id = 0;
      err_msgs = [];
      unload_handlers = [];
      render_params = void 0;
      render_conf = void 0;
      ie_old_attach = void 0;
      w3c_old_attach = void 0;
      ie_old_detach = void 0;
      w3c_old_detach = void 0;
      isAdShown = false;

      /*
      Creates and appends a style sheet for any custom CSS passed
      
      @name $sf.ext-_create_stylesheet
      @function
      @static
      @private
      @param {String} cssText A string of CSS rules, or a URL string
      @param {String} [id] The id attribute of the tag created and appended
       */
      _create_stylesheet = function(cssText, id) {
        var e, oHead, oSS, oTxt;
        oHead = void 0;
        oSS = void 0;
        oTxt = void 0;
        e = void 0;
        try {
          oHead = _tags("head")[0];
          if (cssText.search(/\{[^\}]*}/g) === -1) {
            oSS = dom.make("link");
            oSS.type = "text/css";
            oSS.rel = "stylesheet";
            oSS.href = cssText;
          } else {
            oSS = dom.make("style");
            oSS.type = "text/css";
            if (isIE) {
              oSS.styleSheet.cssText = cssText;
            } else {
              oTxt = d.createTextNode(cssText);
              _append(oSS, oTxt);
            }
          }
          if (id) {
            oSS.id = id;
          }
          _append(oHead, oSS);
        } catch (_error) {}
      };

      /*
      Fires of unload event handlers and performs the necessary clean up when a SafeFrame is destroyed
      
      @name $sf.ext-_destruction
      @function
      @static
      @private
      @param {HTMLEvent} [evt] The raw dom event object if it exists
       */
      _destruction = function(evt) {
        var e, grand_par, handler, success, w;
        handler = void 0;
        w = window;
        success = 1;
        e = void 0;
        try {
          evt = evt || w.event || {};
        } catch (_error) {
          e = _error;
          evt = {
            type: UNLOAD
          };
        }
        while (handler = unload_handlers.shift()) {
          try {
            handler(evt);
          } catch (_error) {}
        }
        try {
          if (ie_old_attach) {
            w[IE_ATTACH] = ie_old_attach;
            w[IE_DETACH] = ie_old_detach;
          }
        } catch (_error) {}
        try {
          if (w3c_old_attach) {
            w[W3C_ATTACH] = w3c_old_attach;
            w[W3C_DETACH] = w3c_old_detach;
          }
        } catch (_error) {}
        if (!hasLoaded) {
          _detach(w, LOAD, _handle_load);
        }
        _detach(w, UNLOAD, _handle_unload);
        try {
          w.onerror = null;
        } catch (_error) {}
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (orphan_timer_id) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        w = ie_old_attach = w3c_old_attach = ie_old_detach = w3c_old_detach = d = _ue = par = handler = grand_par = null;
        return success;
      };

      /*
      Maintains that the window.onmessage property remains unset.
      We don't want content in our document listening to HTML5 messages.
      We override attaching to listeners below to maintain that functionality,
      however IE won't let you override properties directly hangning off of the
      window object, so we have a timer as a fallback for that purpose
      
      @name $sf.ext-_reset_inline_handlers
      @function
      @static
      @private
       */
      _reset_inline_handlers = function() {
        var e;
        e = void 0;
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (isIE && win.onmessage) {
            win.onmessage = null;
          }
        } catch (_error) {}
        try {
          win.onerror = _handle_err;
        } catch (_error) {}
        inline_handler_timer_id = setTimeout(_reset_inline_handlers, DOM_WATCH_INTERVAL);
      };

      /*
      Clears out the HTML document (which will force an unload event as well).
      
      @name $sf.ext-_nuke_doc
      @function
      @static
      @private
       */
      _nuke_doc = function() {
        var e;
        e = void 0;
        try {
          document.open("text/html", "replace");
          document.write("");
          document.close();
        } catch (_error) {}
      };

      /*
      Iteratively checks to see if the IFRAME HTML document is no longer
      attached to the main dom, doing this by checking that our internal
      window reference is still valid. . .as well as running the checks to make
      sure invalid iframes (iframes from origin) are not created.
      
      If we detect that the IFRAME has been removed from the main dom of the
      publisher, then we call to destroy the HTML document, forcing onunload
      event and subsquent cleanup
      
      @name $sf.ext-_check_orphaned
      @function
      @static
      @private
       */
      _check_orphaned = function() {
        var e, is_orphaned;
        is_orphaned = false;
        e = void 0;
        _detect_bad_iframe();
        if (!isIE) {
          return;
        }
        try {
          if (orphan_timer_id && orphan_timer_id !== -1) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          is_orphaned = win === top && orphan_timer_id !== -1;
        } catch (_error) {
          e = _error;
          is_orphaned = false;
        }
        if (is_orphaned) {
          orphan_timer_id = -1;
          _destruction();
          _nuke_doc();
          return;
        }
        try {
          if (!orphan_timer_id) {
            orphan_timer_id = setTimeout(_check_orphaned, DOM_WATCH_INTERVAL);
          }
        } catch (_error) {}
      };

      /*
      Detect whether or not an IFRAME tag has been inserted into the DOM that has the same
      origin / cname as the publisher, which should not be allowed as it's a security issue
      If said IFRAME tag(s) are found, remove them.
      
      @name $sf.ext-_detect_bad_iframe
      @function
      @static
      @private
       */
      _detect_bad_iframe = function() {
        var idx, srcHost, tag, written;
        iframes = _tags("iframe");
        idx = 0;
        srcHost = "";
        written = false;
        tag = void 0;
        if (host_cname) {
          while (tag = iframes[idx++]) {
            srcHost = _attr(tag, "src");
            srcHost = (srcHost && srcHost.length >= 9 ? srcHost.substring(0, srcHost.indexOf("/", 9))[TOLOWERCASE]() : "");
            if (srcHost && srcHost === host_cname && tag.className !== OUR_TAG_CLS_NAME) {
              try {
                _purge(tag);
              } catch (_error) {}
            }
          }
        }
      };

      /*
      Make sure that all hyperlinks in the document are set with the property "target" attribute
      such that links will navigate to the right window properly.
      
      @name $sf.ext-_set_hyperlink_targets
      @function
      @static
      @private
       */
      _set_hyperlink_targets = function() {
        var atgt, idx, ln, lns, ttgt;
        idx = 0;
        ttgt = (render_conf && render_conf.tgt) || "_top";
        ln = void 0;
        atgt = void 0;
        lns = void 0;
        lns = _tags("a");
        if (ttgt === "_self") {
          ttgt = "_top";
        }
        while (ln = lns[idx++]) {
          atgt = _attr(ln, "target");
          if (atgt !== ttgt) {
            _attr(ln, "target", ttgt);
          }
          if (idx > 10) {
            break;
          }
        }
      };

      /*
      Handle the onunload event from the HTML document of the IFRAME, which in turn will trigger clean up
      
      @name $sf.ext-_handle_unload
      @function
      @static
      @private
      @param {HTMLEvent} evt The raw DOM event object
       */
      _handle_unload = function(evt) {
        _destruction(evt);
        _nuke_doc();
      };

      /*
      Handle the load event from the HTML document of the IFRAME, which will also setup
      to make sure link targets are set properly
      
      @name $sf.ext-_handle_load
      @function
      @static
      @private
       */
      _handle_load = function() {
        if (loaded) {
          return;
        }
        hasLoaded = true;
        _detach(win, LOAD, _handle_load);
        _set_hyperlink_targets();
      };

      /*
      Handle onmessage HTML5 x-domain events. We always cancel the event
      never allowing it to go to other listeners besides our own, as we don't allow HTML5 messaging
      beyond us and the publisher / host.
      
      @name $sf.ext-_handle_msg
      @function
      @static
      @private
       */
      _handle_msg = function(evt) {
        var e, msg_guid, msg_obj, msg_params, org, src, str;
        str = void 0;
        src = void 0;
        org = void 0;
        e = void 0;
        msg_params = void 0;
        msg_guid = void 0;
        msg_obj = void 0;

        /*
        TODO, also validate origin
         */
        try {
          str = evt.data;
          src = evt.source;
          org = evt.origin;
        } catch (_error) {}
        dom.evtCncl(evt);
        if (str && src && src === top) {
          msg_params = ParamHash(str, null, null, true, true);
          msg_guid = msg_params.guid;
          msg_obj = msg_params.msg;
          if (guid === msg_guid && msg_obj && typeof msg_obj === OBJ) {
            try {
              setTimeout((function() {
                _receive_msg(msg_obj, evt);
                msg_params = evt = msg_guid = msg_obj = null;
              }), 1);
            } catch (_error) {}
          }
        }
      };

      /*
      This SafeFrames implementation internally handles all event attachment to maintain that the listener order
      for events that it cares about (onload, onunload, onbeforeunload, onmessage).
      This is done to make sure that proper clean up and intialization happens, as well as to enforce
      security.
      
      For events that it SafeFrames does not care about we allow the attachment listeners
      to proceed as normal, so we call the raw attachEvent / addEventListener functions.
      
      @name $sf.ext-_call_raw_evt_func
      @function
      @static
      @private
      @param {String} type The name of the event for which to attach/detach a listener
      @param {Function} f The callback function to use as a listener for said event
      @param {Boolean} [remove] If set to true, remove/detach this function as a listener, otherwise add
       */
      _call_raw_evt_func = function(type, f, remove) {
        var bOK, e, ie_f, w3c_f;
        bOK = false;
        ie_f = void 0;
        w3c_f = void 0;
        e = void 0;
        if (remove) {
          ie_f = ie_old_detach || w3c_old_detach;
          w3c_f = w3c_old_detach;
        } else {
          ie_f = ie_old_attach || w3c_old_attach;
          w3c_f = w3c_old_attach;
        }
        if (ie_f) {
          try {
            ie_f(type, f);
            bOK = true;
          } catch (_error) {
            e = _error;
            bOK = false;
          }
          if (!bOK) {
            try {
              ie_f.call(win, type, f);
              bOK = true;
            } catch (_error) {
              e = _error;
              bOK = false;
            }
          }
        }
        if (w3c_f && !bOK) {
          try {
            w3c_f.call(win, type, f, false);
          } catch (_error) {}
        }
      };

      /*
      Override default event attachment, and send load, beforeunload, and unload handlers into our
      own ques, so that we can enforce the proper firing order.  if message event is passed in,
      we do not allow attachment, since we do not want n-party code listening to HTML5 messages
      
      @name $sf.ext-_attach_override
      @function
      @static
      @private
      @param {String} type the event name to listen too
      @param {Function} f The function to be called whenever the event fires
       */
      _attach_override = function(type, f) {
        var bDoDefault;
        bDoDefault = false;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            unload_handlers.push(f);
            break;
          case MSG:
          case ONMSG:
            true;
            break;
          default:
            bDoDefault = true;
        }
        if (bDoDefault) {
          _call_raw_evt_func(type, f);
        }
      };

      /*
      Override default event detachment, and remove load, beforeunload, and unload handlers
      from our own que.  if message event is passed in, we do nothing (since we don't alllow
      attachment either).  If not one of those event types, then we call the default event detachment
      
      @name $sf.ext-_detach_override
      @function
      @static
      @private
      @param {String} type the event name to unlisten too
      @param {Function} f The function to no longer be called for the specific event
       */
      _detach_override = function(type, f) {
        var handler, handlers, idx;
        idx = 0;
        handler = void 0;
        handlers = void 0;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            handlers = unload_handlers;
            break;
          case MSG:
          case ONMSG:
            true;
        }
        if (handlers != null ? handlers.length : void 0) {
          while (handler = handlers[idx]) {
            if (handler === f) {
              handlers.splice(idx, 1);
              break;
            }
            idx++;
          }
        } else {

        }
        _call_raw_evt_func(type, f, true);
      };

      /*
      Report any internal uncaught JavaScript errors up to the publisher / host
      
      @name $sf.ext-_report_errs
      @static
      @function
      @private
       */
      _report_errs = function() {
        var cmd_str, e, errs;
        e = void 0;
        errs = void 0;
        try {
          if (err_msgs.length > 0) {
            errs = err_msgs[0];
            cmd_str = ["cmd=", ERROR_COMMAND, "&pos=", pos_id, "&errors=", errs];
            _send_msg(_cstr(cmd_str), ERROR_COMMAND);
          }
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        err_msgs = [];
      };

      /*
      Handle any uncaught JavaScript errors
      
      @name $sf.ext-_handle_err
      @static
      @function
      @private
      @param {String} a The the error message / description string
      @param {String} b The URL / file that the JavaScript error occured within
      @param {Number} c The line number that the error occured on. . .
       */
      _handle_err = function(a, b, c) {
        var e;
        e = void 0;
        err_msgs.push(_cstr(["Error occurred inside SafeFrame:\nMessage: ", a, "\nURL:", b, "\nLine:", c]));
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
          err_msg_timer_id = setTimeout(_report_errs, DOM_WATCH_INTERVAL);
        } catch (_error) {}
        return true;
      };

      /*
      Override native window methods and properties so that we can control
      how the events that we need to manage
      
      @name $sf.ext-_setup_win_evt_props
      @static
      @function
      @private
      @param {Object} obj The window object / prototype
       */
      _setup_win_evt_props = function(obj) {
        var O, e, n, nobj, ret;
        n = lang.noop;
        O = Object;
        nobj = {
          get: n,
          set: n
        };
        ret = false;
        if (obj) {
          if (ie_old_attach) {
            obj[IE_ATTACH] = _attach_override;
            obj[IE_DETACH] = _detach_override;
          }
          if (w3c_old_attach) {
            obj[W3C_ATTACH] = _attach_override;
            obj[W3C_DETACH] = _detach_override;
          }
          if (obj[DG]) {
            try {
              obj[DG](ONLOAD, n);
              obj[DS](ONLOAD, n);
              obj[DG](ONUNLOAD, n);
              obj[DS](ONUNLOAD, n);
              obj[DG](ONMSG, n);
              obj[DS](ONMSG, n);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
          if (!ret && O[DP]) {
            try {
              O[DP](obj, ONLOAD, nobj);
              O[DP](obj, ONUNLOAD, nobj);
              O[DP](obj, ONMSG, nobg);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
        }
        return ret;
      };

      /*
      Intialize / setup the safeframe, the environment according to the configuration found within the serialized
      window.name property.
      
      @name $sf.ext-_construction
      @param {Object} [details] An optional object to pass in status / error information into
      @static
      @private
      @function
       */
      _construction = function(details) {
        var cont, cur_time, e, el, guid_time, nm, ret, temp, time_delta;
        cont = false;
        ret = true;
        el = void 0;
        nm = void 0;
        temp = void 0;
        cur_time = void 0;
        guid_time = void 0;
        time_delta = void 0;
        e = void 0;
        details = (details && (details instanceof Object) ? details : {});
        try {
          nm = win.name;
        } catch (_error) {}
        try {
          win.name = "";
        } catch (_error) {}
        if (!nm) {
          details.status = 500.101;
          return cont;
        }
        try {
          if (top === par) {
            render_params = ParamHash(nm, null, null, true, true);
            cur_time = lang.time();
            guid = render_params.guid;
            guid_time = _cnum(guid.replace(/[^_]*_(\d+)_\d+_\d+/g, "$1"), 0);
            time_delta = cur_time - guid_time;
            cont = guid && guid_time && time_delta > 0 && time_delta < GUID_VALID_TIME;
            if (render_params.loc) {
              render_params.loc = unescape(render_params.loc);
            }
            if (!cont) {
              details.status = 500.104;
            }
          } else {
            details.status = 500.102;
          }
        } catch (_error) {
          e = _error;
          render_params = guid = null;
          cont = false;
          details.status = 500.103;
        }
        if (cont) {
          try {
            render_conf = render_params.conf;
            frame_id = win.name = render_conf.dest;
            pos_id = render_conf.id;
            pos_meta = render_params.meta;
            host_cname = render_params.host;
            geom_info = render_params.geom;
            can_use_html5 = lang.cbool(render_params.html5);
            win_has_focus = lang.cbool(render_params.has_focus);
            temp = render_conf.bg;
            if (geom_info) {
              geom_info = ParamHash(_ue(geom_info), null, null, true, true);
              if (!geom_info.self || !geom_info.exp) {
                geom_info = null;
              }
            }
            if (!host_cname) {
              host_cname = d.referrer;
              host_cname = host_cname.substring(0, host_cname.indexOf("/", 9));
            }
            if (temp) {
              _create_stylesheet(_cstr(["#sf_body { background-color: ", temp, "; }"]), "sf_bg_css");
            }
            temp = render_conf.tgt;
            if (temp === "_self") {
              render_conf.tgt = "_top";
            }
            if (!temp) {
              render_conf.tgt = "_top";
            }
            if (temp !== "_top") {
              while (_purge(_tags("base")[0])) {
                true;
              }
            }
            el = dom.make("base");
            _attr(el, "target", temp);
            _append(_tags("head")[0], el);
            if (isIE) {
              ie_old_attach = win[IE_ATTACH];
              ie_old_detach = win[IE_DETACH];
            }
            w3c_old_attach = win[W3C_ATTACH];
            w3c_old_detach = win[W3C_DETACH];
            _attach(win, UNLOAD, _handle_unload);
            _attach(win, LOAD, _handle_load);
            _attach(win, MSG, _handle_msg);
            _setup_win_evt_props(win);
            _setup_win_evt_props(win.__proto__);
            _setup_win_evt_props(win.Window && win.Window.prototype);
          } catch (_error) {
            e = _error;
            details.status = 500.105;
            render_params = render_conf = guid = null;
            ret = false;
          }
        } else {
          render_params = guid = null;
          ret = false;
        }
        return ret;
      };
      _wrapiFrame = function(html, cbName) {
        return "<iframe style=\"width:100%;height:100%;\" allowtransparency=\"true\"\nscrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\" onload='" + cbName + "()'>\n<html><head><base target=\"_top\"></head><body style=\"margin: 0; padding: 0\">\n<script>\n  $ad = window.parent.$ad\n  $sf = window.parent.$sf\n</script>\n  " + html + "\n</html>\n</iframe>";
      };
      originalWrite = document.write;

      /*
      Render the HTML and CSS content passed in through the window.name message via a document.write
      
      @name $sf.ext-_render
      @function
      @static
      @private
       */
      _render = function(contentOverride, callback) {
        var cbName, css, e, html, otherCallbackApplied;
        if (callback == null) {
          callback = function() {};
        }
        cbName = lib.lang.guid("load_cb");
        otherCallbackApplied = false;
        window[cbName] = function(fromFrame) {
          return (sf.lib.lang.wrap(callback, function() {
            if (fromFrame || !otherCallbackApplied) {
              callback.apply(sf, arguments);
              _handle_load();
              loaded();
              document.write = originalWrite;
              return window[cbName] = lang.noop;
            }
          }))();
        };
        document.write = function(str) {
          var domElem, iframe, oldOnload, _i, _len, _ref;
          if (!(hasLoaded || otherCallbackApplied)) {
            domElem = document.createElement("div");
            domElem.innerHTML = "_" + str;
            _ref = domElem.getElementsByTagName("iframe");
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              iframe = _ref[_i];
              if (_cnum(_attr(iframe, "width"), 0) > 1) {
                otherCallbackApplied = true;
                if (oldOnload = _attr(iframe, "onload")) {
                  _attr(iframe, "onload", "" + cbName + "(true);" + oldOnload + ";");
                } else {
                  _attr(iframe, "onload", "" + cbName + "(true);");
                }
                break;
              }
            }
            if (otherCallbackApplied) {
              str = domElem.innerHTML.substring(1);
            }
          }
          return originalWrite.call(this, str);
        };
        html = void 0;
        css = void 0;
        isAdShown = true;
        css = _cstr(render_conf && render_conf.css);
        html = contentOverride || _cstr(render_params && render_params.html);
        if (css) {
          css = _ue(css);
          _create_stylesheet(css, "sf_custom_css");
        }
        if (html) {
          html = _ue(html);
          try {
            _reattach_messaging();
            _requested();
            document.write(html + "<scr" + ("ipt> " + cbName + "() ;</scr") + "ipt>");
            _check_orphaned();
            _reset_inline_handlers();
          } catch (_error) {
            e = _error;
            _handle_err("Error while rendering content: " + e[MSG]);
          }
        }
      };

      /*
      Call into the fallback x-msging library client if possible when no HTML5 style messaging
      exists
      
      @name $sf.ext-_call_client_fb
      @function
      @private
      @static
      @param {String} methName The name of the message in the library to call
      @param {*} [arg1] An arbitrary argument to hand into the library
      @param {*} [arg2] An arbitrary argument to hand into the library
       */
      _call_client_fb = function(methName, arg1, arg2) {
        var msg_clientfb;
        if (msgclient_fb) {
          msg_clientfb = dom.msgclient_fb;
        }
        return methName && msgclient_fb && msgclient_fb[methName] && msgclient_fb[methName](arg1, arg2);
      };

      /*
      Process a validated message to notify the contents of the SafeFrame of state updates
      
      @name $sf.ext-_receive_msg
      @function
      @private
      @static
      @param {$sf.lib.lang.ParamHash} params The message parameter hash object containing information about what has occured
      @param {HTMLEvent} [evt] The raw DOM event from the x-domain message
      @return {Boolean} Whether or not the message received could be handled
       */
      _receive_msg = function(params, evt) {
        var cmd, data, e, g, msg, ret;
        ret = false;
        msg = void 0;
        cmd = void 0;
        g = void 0;
        e = void 0;
        data = {};
        if (params) {
          g = params.geom || "";
          cmd = params.cmd;
          if (g) {
            geom_info = ParamHash(_ue(g), null, null, true, true);
          }
        }
        data.cmd = cmd;
        data.value = data.info = params && params.value;
        data.reason = params && params.reason;
        if (cmd === NOTIFY_COLLAPSED) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            force_collapse = true;
            _collapse();
            force_collapse = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_COLLAPSE) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_EXPAND) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            is_expanded = true;
            _fire_sandbox_callback(NOTIFY_EXPAND + "ed");
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_GEOM_UPDATE) {
          _fire_sandbox_callback(NOTIFY_GEOM_UPDATE);
        } else if (cmd === NOTIFY_FOCUS_CHANGE) {
          data.info = data.value = lang.cbool(data.value);
          win_has_focus = data.value;
          _fire_sandbox_callback(NOTIFY_FOCUS_CHANGE, data);
        } else if (cmd === NOTIFY_READ_COOKIE) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            data = params && params.value;
            _fire_sandbox_callback(NOTIFY_READ_COOKIE, data);
            _shiftMessageQueue();
          }
        } else if ([NOTIFY_WRITE_COOKIE, NOTIFY_FAILURE, NOTIFY_CLICKED, NOTIFY_VIEWED, NOTIFY_UNVIEWED, NOTIFY_LOADED, NOTIFY_REQUESTED, NOTIFY_RELOAD].indexOf(cmd) > -1) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
          _shiftMessageQueue();
        } else {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
          _shiftMessageQueue();
        }
        params = null;
        return ret;
      };
      cmdRetries = {};

      /*
       */
      _shiftMessageQueue = function() {
        var result;
        if (result = messageQueue.shift()) {
          return _send_msg.apply(this, result);
        }
      };

      /*
      Send a command message up to the SafeFrames publisher / host code
      
      @name $sf.ext-_send_msg
      @private
      @function
      @static
      @param {String} str An encoded string (query-string/$sf.lib.lang.ParamHash format) that contains the command message to send
      @param {String} cmd The command to be sent itself (note that this string should also be present in the 1st argument)
       */
      _send_msg = function(str, cmd) {
        var e, id, params, sent, sent_time;
        id = lang.guid("sf_pnd_cmd");
        frame_id = render_params.dest;
        sent = false;
        sent_time = lang.time();
        params = void 0;
        if (!str || !cmd || pending_msg) {
          if (pending_msg) {
            messageQueue.push([str, cmd]);
          }
          return;
        }
        params = ParamHash({
          msg: str,
          id: frame_id,
          guid: guid,
          cmd: cmd
        });
        pending_msg = {
          id: id,
          sent: sent_time,
          cmd: cmd
        };
        setTimeout((function() {
          if (pending_msg && pending_msg.id === id) {
            if (cmd === EXPAND_COMMAND || cmd === "exp-push") {
              force_collapse = true;
              _collapse();
              force_collapse = false;
            }
            _fire_sandbox_callback(NOTIFY_FAILURE + ":" + cmd + ":timeout");
          }
          id = sent = sent_time = cmd = str = pending_msg = params = null;
          _shiftMessageQueue();
        }), MAX_MSG_WAIT_TIME);
        if (can_use_html5) {
          try {
            top.postMessage(params.toString(), (host_cname === "file" || host_cname === "" ? "*" : host_cname));
            sent = true;
          } catch (_error) {
            e = _error;
            sent = false;
          }
        }
        if (!sent) {
          _call_client_fb("send", params);
        }
      };

      /*
      Fire a notification off to the SafeFrame contents if a callback function was specified
      
      @name $sf.ext-_fire_sandbox_callback
      @private
      @function
      @static
      @param {String} msg The status update / message to send
      @param {Object} data The data from the response
       */
      _fire_sandbox_callback = function(msg, data) {
        var e;
        e = void 0;
        try {
          if (typeof sandbox_cb === "function") {
            sandbox_cb(msg, data);
          }
        } catch (_error) {}
      };

      /*
      Set the alignment of our internal DIV whenever expansion occurs uni-directionaly
      
      @name $sf.ext-_set_alignment
      @private
      @function
      @static
      @param {Boolean} xn Whether or not horizontal axis is growing to the left or right (xn == true == left)
      @param {Boolean} yn Whether or not vertical axis is growing to the top or bottom (yn == true == top)
       */
      _set_alignment = function(xn, yn) {
        var fcDiv, fcDivStyle, preTxt, xTxt, yTxt;
        fcDiv = _elt("sf_align");
        fcDivStyle = fcDiv.style;
        xTxt = void 0;
        yTxt = void 0;
        preTxt = "position:absolute;";
        if (xn) {
          xTxt = "right:0px;";
        } else {
          xTxt = "left:0px;";
        }
        if (yn) {
          yTxt = "bottom:0px;";
        } else {
          yTxt = "top:0px;";
        }
        fcDivStyle.cssText = preTxt + xTxt + yTxt;
        fcDiv = fcDivStyle = null;
      };

      /*
      Internal function for collapsing the SafeFrame, which checks that there is
      not some other pending state which may get in the way
      
      @name $sf.ext._collapse
      @private
      @function
      @static
       */
      _collapse = function() {
        if (!force_collapse && (!is_registered || !is_expanded || pending_msg)) {
          return false;
        }
        _set_alignment(0, 0);
        return true;
      };
      _reattach_messaging = function() {
        if (ie_old_attach) {
          ie_old_detach(ONMSG, _handle_msg);
          return ie_old_attach(ONMSG, _handle_msg);
        } else if (w3c_old_attach) {
          w3c_old_detach(MSG, _handle_msg);
          return w3c_old_attach(MSG, _handle_msg);
        }
      };

      /*
      Intialize the SafeFrame external vendor/client API, so that other features may be used
      This method MUST be called prior to using any other rich-media functionality (like expansion).
      
      @name $sf.ext.register
      @public
      @function
      @static
      @param {Number} initWidth The initial width (in pixels) expected of the content within the SafeFrame container
      @param {Number} initHeight The initial height (in pixels) expected of the content within the SafeFrame container
      @param {Function} [notify] A callback function that content can specify to be notified of status updates
       */
      register = function(initWidth, initHeight, notify) {
        if (is_registered || !guid) {
          return;
        }
        initWidth = _cnum(initWidth, 0, 0);
        initHeight = _cnum(initHeight, 0, 0);
        init_width = initWidth;
        init_height = initHeight;
        is_registered = true;
        if (lang.callable(notify)) {
          sandbox_cb = notify;
        } else {
          sandbox_cb = null;
        }
      };

      /*
      Make a request to expand the SafeFrame container to a certain size. Note that you may only call $sf.ext.expand
      to expand to the largest size needed, followed by calling collapse (and then repeat the same process if needed).
      Tweening or animation done, should be reserved for your own content, and you cannot make multiple calls to expand
      without a corresponding collapse.
      
      Note that when setting t, l, b, and r offset values, expansion will not cause the content inside the SafeFrame
      to hold it's current alignment, whereas using dx/dy or only setting partial offfsets (e.g {t:100,l:100} ==  dx:-100,dy:-100) will cause expansion to
      hold it's current alignment.
      
      @name $sf.ext.expand
      @public
      @static
      @function
      @param {Number|Object} deltaXorDesc If a number is specifed, SafeFrame will grow in size by this amount in pixels along the horizontal axis. Specifiy a negative value to grow to the left, and a postive value to grow to the right. <br />
      If an object is specified, it should contain "t","l","r","b" properties (top,left,bottom,right) for the amount in pixels to grow the container in each dimension
      @param {Number} deltaXorDesc.t Specifies to shift the top position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.l Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.b Specifies to shift the bottom position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Number} deltaXorDesc.r Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Boolean}deltaXorDesc.push  When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      @param {Number} deltaY If a number is specifed, SafeFrame will grow in size by this amount in pixels along the vertical axis. Specifiy a negative value to grow to the top, and a postive value to grow to the bottom. <br />
      Note that this value is ignored if deltaXorDesc is passed in as an object.
      
      @param {Boolean} push When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      
      @return {Boolean} true/false if the request to expand the container was sent. This does not mean that expansion is complete as expansion is an asynchronous process. Pass in a callback function to $sf.ext.register to get status updates.
       */
      expand = function(deltaXorDesc, deltaY, p) {
        var align_buffer, align_el, align_el_st, b, cmd_nm, cmd_str, doAlign, dx, dy, l, r, t, xn, yn;
        xn = false;
        yn = false;
        doAlign = false;
        cmd_nm = (p ? "exp-push" : EXPAND_COMMAND);
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id];
        dx = 0;
        dy = 0;
        r = void 0;
        b = void 0;
        t = void 0;
        l = void 0;
        align_el = void 0;
        align_el_st = void 0;
        align_buffer = void 0;
        if (!is_registered || pending_msg) {
          return;
        }
        if (p && !supports("exp-push")) {
          return;
        }
        if (deltaXorDesc && typeof deltaXorDesc === OBJ) {
          r = _cnum(deltaXorDesc.r, 0, 0);
          b = _cnum(deltaXorDesc.b, 0, 0);
          t = _cnum(deltaXorDesc.t, 0, 0);
          l = _cnum(deltaXorDesc.l, 0, 0);
          if (deltaXorDesc.push) {
            if (!supports("exp-push")) {
              return;
            }
            cmd_nm = "exp-push";
            cmd_str[1] = cmd_nm;
          }
          if (!r && l) {
            xn = true;
            dx = -1 * l;
          }
          if (r && !l) {
            dx = r;
          }
          if (!b && t) {
            yn = true;
            dy = -1 * t;
          }
          if (b && !t) {
            dy = b;
          }
          if ((t && b) || (l && r)) {
            doAlign = false;
          } else {
            doAlign = true;
          }
          if (doAlign) {
            _set_alignment(xn, yn);
            cmd_str.push("&dx=", dx, "&dy=", dy);
            _send_msg(_cstr(cmd_str), cmd_nm);
          } else {
            align_el = _elt("sf_align");
            align_el_st = align_el && align_el.style;
            align_buffer = ["position:absolute;"];
            if (t && b) {
              align_buffer.push("top:", t, "px;");
            } else if (t) {
              align_buffer.push("bottom:0px;");
            } else {
              if (b) {
                align_buffer.push("top:0px;");
              }
            }
            if (l && r) {
              align_buffer.push("left:", l, "px;");
            } else if (l) {
              align_buffer.push("right:0px;");
            } else {
              if (b) {
                align_buffer.push("left:0px;");
              }
            }
            if (align_el_st) {
              align_el_st.cssText = _cstr(align_buffer);
            }
            cmd_str.push("&exp_obj=", escape(ParamHash(deltaXorDesc)));
            _send_msg(_cstr(cmd_str), cmd_nm);
          }
        } else {
          deltaXorDesc = _cnum(deltaXorDesc, 0);
          deltaY = _cnum(deltaY, 0);
          if (deltaXorDesc <= 0 && deltaY <= 0) {
            return;
          }
          xn = deltaXorDesc <= 0;
          yn = deltaY <= 0;
          _set_alignment(xn, yn);
          cmd_str.push("&dx=", deltaXorDesc, "&dy=", deltaY);
          _send_msg(_cstr(cmd_str), cmd_nm);
        }
        return true;
      };

      /*
      Collapse the SafeFrame container after having called to expand. If no previous call to expand has been made, this call will do nothing.
      
      @name $sf.ext.collapse
      @public
      @static
      @function
       */
      collapse = function() {
        if (_collapse()) {
          _send_msg(_cstr(["cmd=", COLLAPSE_COMMAND, "&pos=", pos_id]), COLLAPSE_COMMAND);
        }
      };
      click = function() {
        return _send_cmd(NOTIFY_CLICKED);
      };
      viewed = function() {
        return _send_cmd(NOTIFY_VIEWED);
      };
      loaded = function() {
        return _send_cmd(NOTIFY_LOADED);
      };
      unviewed = function() {
        return _send_cmd(NOTIFY_UNVIEWED);
      };
      reload = function() {
        return _send_cmd(NOTIFY_RELOAD);
      };
      _requested = function() {
        _fire_sandbox_callback(NOTIFY_REQUESTED);
        return _send_cmd(NOTIFY_REQUESTED);
      };
      _send_cmd = function(cmd) {
        return _send_msg(_cstr(["cmd=", cmd, "&pos=", pos_id]), cmd);
      };

      /*
      Return geometric information about the SafeFrame container and it's status within a page
      
      @name $sf.ext.geom
      @public
      @static
      @function
      @return {Object} geom_info
       */
      geom = function() {
        return geom_info;
      };

      /*
      Return meta-data information that may have been specified by the publisher / host.
      
      @name $sf.ext.meta
      @public
      @static
      @function
      @param {String} propName the key name of the meta-data value to be retrieved
      @param {String} [owner_key] the super key name of the data to be retrieved
      @return {String} The value of some meta-data that may have been specified by the publisher / host or "".
       */
      meta = function(propName, owner_key) {
        var ret, shared;
        ret = "";
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              ret = _cstr(pos_meta[owner_key][propName]);
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                ret = _cstr(pos_meta.non_shared[owner_key][propName]);
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              ret = _cstr(shared[propName]);
            }
          }
        }
        return ret;
      };
      deleteMeta = function(propName, owner_key) {
        var shared;
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              return delete pos_meta[owner_key][propName];
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                return delete pos_meta.non_shared[owner_key][propName];
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              return delete shared[propName];
            }
          }
        }
      };

      /*
      Return the current status of the SafeFrame container, in cases where
      a command may be pending. If an empty string is returned ("") container is idle.
      
      @name $sf.ext.status
      @public
      @static
      @function
      @return {String} of any pending status, otherwise empty string.
       */
      status = function() {
        if (pending_msg) {
          if (pending_msg.cmd === EXPAND_COMMAND) {
            return STATUS_EXPANDING;
          } else {
            if (pending_msg.cmd === COLLAPSE_COMMAND) {
              return STATUS;
            }
          }
        }
        if (is_expanded) {
          return STATUS_EXPANDED;
        } else {
          return STATUS_COLLAPSED;
        }
      };

      /*
      Requests the host read or write a cookie to the host domain.
      The host domain must grant permission for the cookie to be written.
      
      @name $sf.ext.cookie
      @public
      @static
      @function
      @param {String} [cookieName] The name of the cookie to set or read
      @param {Object} [cookieData] An object hash containing the value and an optional expires
      @return {Number}
       */
      cookie = function(cookieName, cookieData) {
        var cmd_nm, cmd_str, isRead;
        isRead = !(cookieData != null);
        cmd_nm = (isRead ? "read-cookie" : "write-cookie");
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id, "&cookie=", cookieName];
        if (!isRead) {
          cmd_str.push("&value=");
          cmd_str.push(cookieData.value);
          if (cookieData.expires) {
            cmd_str.push("&expires=" + (+cookieData.expires));
          }
        }
        _send_msg(_cstr(cmd_str), cmd_nm);
      };

      /*
      Send a message to the host
      
      @name $sf.ext.message
      @public
      @static
      @function
       */
      message = function(content) {
        _send_msg(_cstr(["cmd=", "msg", "&pos=", pos_id, "&msg=", content]), "msg");
      };

      /*
      Return the percentage that the SafeFrame container is viewable within the browser window
      
      @name $sf.ext.inViewPercentage
      @public
      @static
      @function
      @return {Number}
       */
      inViewPercentage = function() {
        var iv, tv;
        iv = _cnum(geom_info && geom_info.self && geom_info.self.iv, -1, 0);
        tv = void 0;
        if (iv >= 0) {
          tv = Math.floor(iv * 100);
        }
        return tv;
      };
      winHasFocus = function() {
        return win_has_focus;
      };

      /*
      Return whether or not a particular feature is supported, or an object containing
      key/value pairs denoting all features and whether or not they are supported
      
      By default SafeFrames version 1 supports the following feature:
      
      "exp-ovr": Expansion of the container by overlaying on top of other content
      
      Later in other versions there are expexted to be more feature with their own
      string name, that can be checked by the content in the SafeFrame, so that
      it knows what things can be done.
      
      @name $sf.ext.supports
      @public
      @static
      @function
      @param {String} [key] If specifed, checks to see if that specific feature has been enabled
      @return {Boolean|Object}
       */
      supports = function(key) {
        var conf, sup;
        conf = render_params.conf;
        sup = (conf && conf.supports) || false;
        if (sup) {
          key = _cstr(key);
          if (key) {
            sup = sup[key] || false;
            if (sup === "0") {
              sup = false;
            }
          } else {
            sup = lang.mix({}, sup);
          }
        }
        return sup;
      };
      render = function(showAd, contentOverride, cb) {
        var err_info;
        err_info = {};
        if (_construction(err_info)) {
          if (showAd) {
            return _render(contentOverride, cb);
          }
        }
      };
      showAd = function(contentOverride, cb) {
        if (!isAdShown) {
          return _render(contentOverride, cb);
        }
      };
      adShown = function() {
        return isAdShown;
      };
      lang.mix(sf.ext, {
        register: register,
        expand: expand,
        collapse: collapse,
        geom: geom,
        meta: meta,
        deleteMeta: deleteMeta,
        status: status,
        supports: supports,
        cookie: cookie,
        message: message,
        inViewPercentage: inViewPercentage,
        winHasFocus: winHasFocus,
        click: click,
        viewed: viewed,
        unviewed: unviewed,
        showAd: showAd,
        adShown: adShown,
        reload: reload
      });
      if (!isExternal) {
        window.$sf = sf;
        render();
      } else {
        window.$sf = sf;
        sf.ext.render = render;
      }
      return sf;
    })(window, sf);
  };

}).call(this);
